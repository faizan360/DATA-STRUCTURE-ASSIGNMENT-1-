# -*- coding: utf-8 -*-
"""DATA STRUCTURE ASSIGNMENT 1 (200901110)

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1oEgkrmd2Gv3pBfV-AY87rajbmCP_QLcO

DATA STRUCTURE AND ALGORITHM//
ASSIGNMENT-1//
NAME : FAIZAN MAHMOOD //
REG : 200901110 //
CLASS : BSCS (01A) //
"""

class Empty(Exception): #Q6.1
    pass
class ArrayStack:
    
    
    def __init__(self):
        self._data = []
        
    def __len__(self):
        return len(self._data)
    
    def is_empty(self):
        return len(self._data) == 0
    
    def push(self, e):
        self._data.append(e)
        
    def top(self):
        if self.is_empty():
            raise Empty('Stack is empty')
        return self._data[-1]
    
    def pop(self):
        if self.is_empty():
            raise Empty('Stack is empty')
        return self._data.pop()
x = ArrayStack()
x.push(5)
x.push(3)
x.pop()
x.push(2)
x.push(8)
x.pop()
x.pop()
x.push(9)
x.push(1)
x.pop()
x.push(7)
x.push(6)
x.pop()
x.pop()
x.push(4)
x.pop()
x.pop()

"""Q6.2
top doens't add or remove any element, so we can ignore those

If 3 pop operations failed, we only effectively had 7 complete pops

Therefore, we should have 25-7 = 18 elements in the stack
"""

class Empty(Exception):#Q6.3
    pass

class Stack():
    def __init__(self):
        self._data = []
         
    def __len__(self):
        return len(self._data)
    
    def is_empty(self):
        return len(self._data) == 0
    
    def push(self, value):
        self._data.append(value)
    
    def top(self):
        return self._data[-1]
    
    def pop(self):
        if self.is_empty():
            raise Empty('List is empty')
        return self._data.pop()
    
    def full_pop(self):
        ans = []
        while not self.is_empty():
            ans.append(self.pop())
        return ans
    
def transfer(S, T):
    while not S.is_empty():
        T.push(S.pop())



S,T = Stack(), Stack()

try: S.pop()
except Exception as e: print (e)

for i in range(20):
    S.push(i)
    
print('Top of S is: ', S.top())
transfer(S, T)  
print('Top of T is: ', T.top())
S.full_pop(), T.full_pop()

class RStack(Stack): #Q6.4
    def full_pop(self, in_order = False): #override the Stack.full_pop method
        if self.is_empty():
            return []
        else:
            ans = [self.pop()]
            data =  self.full_pop(in_order)
            if in_order: ans, data = data, ans
            data.extend(ans)
            return data

        
        
#Option 2, O(n) for outputs in order
class R2Stack(Stack):
    def _full_pop_r(self, results, counter):
        if self.is_empty():
            return None
        else:
            results[counter] = self.pop()
            counter += 1
            self._full_pop_r(results, counter)
        
    
    
    def full_pop(self): #override the Stack.full_pop method
        results = [None]*len(self)
        counter = 0
        self._full_pop_r(results, counter)
        
        return results


    
    
S = RStack()
for i in range(20):S.push(i)
print('Option 1:', S.full_pop(in_order = True))


S2 = R2Stack()
for i in range(20):S2.push(i) 
print('Option 2:', S2.full_pop())

def reverse_list(S): #Q6.5
    temp = Stack()
    for e in S:
        temp.push(e)
    
    for i in range(len(S)):
        S[i] = temp.pop()

lists = [[1,2,3,4,5,6],
        [3,2,5,6,7,8,9,5],
        [9,8,7,6,5,4,3,2,1]]

for l in lists:
    print ('Before: ', l)
    reverse_list(l)
    print('After:  ', l)
    print()

""" Q6.6
 This is a sloppy implementation of this solution!


I'm not entirely sure what this problem is asking since the solution presented 
in Code Fragment 6.4 would work here as well.  Instead, I think it might be checking
that the order is (sequence that produces a num) operator (sequence that produces a num)

ex.. (5+4)*(3/(2+3)) is correct

The recursive aspect would involve checking that the values within a set of brackets is also an arithmetic expression,
with the base case being that you don't find any 



Add to stack until you get to a close bracket, then perform a 'check pop' until you get to the previous open bracket.
The result should be a number


An alternative approach using recursion is to focus more on the (sequence that produces a num) operator (sequence that produces a num)

Which means that you start by either finding a number or an (.  If you find an (, recurse to see if it collapses into 
a number.  If so, then look for an operation and the next number, and see if those collapse as well

Every time you see the num op num patterns you collapse into one number
"""

class AlgoStack(Stack):#Q6.6
    def __repr__(self):
        return str(self._data)
    
    
    OPEN, CLOSE, OPERATORS = '(', ')', '+-/*^'
    NUMBERS = '1234567890.'
    def pop_until_open(self):
        operator = True
        while not self.is_empty():
            ans = self.pop()
            if ans in self.OPERATORS:
                if operator: return False
                else: operator = True
                    
            elif ans in self.NUMBERS:
                operator = False
                
            elif ans in self.CLOSE: return False
            elif ans in self.OPEN: 
                self.push('3')
                return True  
            
        return False  #if you don't find an open bracket, there is a mismatch
    
    def check_expression(self, expression):
        for char in expression:
            
            if char in self.CLOSE:
                if not self.pop_until_open(): return False
            else: self.push(char)
        return True
    

    
exps = ['(5+4)*(3/(2+3))',
       '(5+4+)*(3/(2+3))',
        '(5+4))*(3/(2+3))',
       '5+(5+4)*(3/(2+3))']
for exp in exps:
    ss = AlgoStack()
    print(exp, ss.check_expression(exp))

"""Q6.7
Return   Values in the Stack
-        [5]
-        [5,3]
5        [3]
-        [3,2]
-        [3,2,8]
3        [2,8]
2        [8]
-        [8,9]
-        [8,9,1]
8        [9,1]
-        [9,1,7]
-        [9,1,7,6]
9        [1,7,6]
1        [7,6]
-        [7,6,4]
7        [6,4]
6        [4]

Q6.8
 Like before, a dequeue operation that fails doesn't remove anything from the queue, so there are essentially 10 dequeues 
 First operations don't change the queue at all
 Therefore we have 32-10 = 22 (the size of the queue is 22 at that point

Q6.9 
Since it was initially an empty queue, we will assume the front value was initially 0 (althogh this is
not necessarily the case since you can empty the queue when front is a value other than 1)

self._front only increments when a dequeue takes place so the final value would be 10 ahead of its initial value, 
or self._front == 10 is self._front was initially 0 as assumed. More generally, it's (10+initial) % 30

Q6.10
This method will copy the data in exactly, but now there will be a huge gap between the middle of the data
filled with None and the next value (which is situated at ._data[0])

ex. a queue with 1,2,3,4,5,6,7 with front = 3:
      F
5,6,7,1,2,3,4

would become:
      F
5,6,7,1,2,3,4,N,N,N,N,N,N,N

the next insertion would be at front + self._size, which would be:
      F
5,6,7,1,2,3,4,N,N,N,8,N,N,N and so on, which results in the fragmentation of the data.  Successive dequeues would 
result in 1,2,3,4,N,N,N,....., N,N instead of the desired 1,2,3,4,5,6,7, is_empty==True


In contract, the walk assures that the data will stay both in order and in direct sequence, producing:

F
1,2,3,4,5,6,7,N,N,N,N,N,N,N
"""

import collections #Q6.11

class Queue():
    def __init__(self):
        self._data = collections.deque()
        self._size = 0
        
        
    def __len__(self):
        return self._size
    
    def first(self):
        return self._data[0]
        
    def enqueue(self, value):
        self._size += 1
        self._data.append(value) 
        
    def is_empty(self):
        return self._size == 0
    
    def dequeue(self):
        if self.is_empty():
            raise ValueError('Queue is empty')
        else:
            ans = self._data.popleft()
            self._size -= 1
            return ans
        
        
dq = Queue()

for i in range(10):
    dq.enqueue(i)

    
print('First', dq.first(), 'Length', len(dq))
while not dq.is_empty():
    print( dq.dequeue(),  end = ', ')

Q6.12
Return   Values in the Stack
-        [4]
-        [4, 8]
-        [4, 8, 9]
-        [5, 4, 8, 9]
9        [5, 4, 8, 9] (the back operation - I'm assuming they meant last() based on their implementation)
5        [4, 8, 9]
9        [4,8]
-        [4,8,7]
4        [4,8,7]
7        [4,8,7]
-        [4,8,7,6]
4        [8,7,6]
8        [7,6]

import collections #Q6.13

#Setup
D = collections.deque()
Q = Queue()
for i in range(1, 9, 1):
    D.append(i)
    
    
def rearrange_using_queue(D, Q):    
    for i in range(5):             #   D          Q
        Q.enqueue(D.popleft())     #[6,7,8], [1,2,3,4,5]
        
    for i in range(3):
        D.append(Q.dequeue())      #[6,7,8,1,2,3], [4,5]
        
    
    for i in range(2):
        D.appendleft(Q.dequeue())  #[5,4,6,7,8,1,2,3], []
        
    for i in range(3):
        Q.enqueue(D.pop())         #[5,4,6,7,8], [3,2,1]
    
    for i in range(3):
        D.appendleft(Q.dequeue())  #[1,2,3,5,4,6,7,8]
    
    
rearrange_using_queue(D, Q)

print('Values of Q:')
while not Q.is_empty():
    print(Q.dequeue())
    
    
print('Values of D')
while len(D) != 0:
    print(D.popleft())

import collections  #Q6.14

S = Stack()
D = collections.deque()

for i in range(1,9,1):
    D.append(i)
    

    
def rearrange_using_stack(D, S):
    for _ in range(4):
        S.push(D.popleft())    # [5,6,7,8], [1,2,3,4]
        
    D.append(S.pop())          # [5,6,7,8,4], [1,2,3]
    
    S.push(D.popleft())        # [6,7,8,4], [1,2,3,5]
    
    S.push(D.pop())            # [6,7,8], [1,2,3,5,4]
    
    for _ in range(5):
        D.appendleft(S.pop())  #[1,2,3,5,4,6,7,8], []
    
    
    
    
    
rearrange_using_stack(D, S) 
    
    
print('Values of S')
while not S.is_empty():
    print(S.pop())
    
print('Values of D:')
while len(D) != 0:
    print(D.popleft())